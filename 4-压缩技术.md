## 第四章 多媒体数据压缩技术

### 4.1  压缩编码简介

**多媒体数据压缩编码的必要性**

主要依据:数据冗杂,实际辨认极限

1. 空间冗余
2. 时间冗余
3. 结构冗余
4. 感觉冗余
5. 知识冗余

**无损压缩**

**有损压缩**

### 4.2 无损压缩算法

#### 4.2.1 信息熵及其基本概念

**信息熵编码**

信息量与信息熵

信息量:设从N个数中选定任意一个数的概率为p,  $I(x_j)=-\log_2{p(x_j)}$

信息熵:$H(S)=\sum\limits_{i=1}^nP_i\log_2{(1/P_i)}$

编码是指将各种信息以码符号的序列来表示

基本概念

![image-20230424133622750](https://cdn.staticaly.com/gh/LuoChen-LC/picx-images-hosting@master/20230603/image-20230424133622750.tlzkbuaa5k0.png)

平均编码长度:$\bar{L}=\sum\limits_{j-1}^nP_il_j$

平均编码长度一定满足：$H(S)\le \bar{L}$

#### 4.2.2 Shannon-Fano 编码

**信息熵编码**也称为统计编码，是利用信息源出现的概率来进行编码

**Shannon编码**：

1. 首先按照符号出现的频度或概率由大到小排序
2. 根据$-\log_2P_i$估计$b_i$，向上取整
3. 形成单一可译码，计算概率相加$\sum\limits_{k=1}^{i-1}P_k$，将其记为二进制小数，取小数点后$b_i$位，作为相应的编码

**Shannon-Fano编码**

1. 频率从大到小排序
2. 将序列分成上下两部分，使得上部频率总和尽可能接近下部频率总和
3. 将上部作为二叉树的左子树，记0，下部作为右子树，记1
4. 分别对左右子树重复2，3步直到所有符号都成为二叉树的叶子结点

#### 4.2.3 Huffman编码

**Huffman编码**

1. 找出两个具有最小概率的节点，构造一个二叉树，根节点看作为新的节点（概率为两个叶子节点概率之和）
2.  根节点与未处理的节点形成新的节点集合，重复上述过程， 直到节点集合中只剩一个节点为止
3. 根据编码树构造编码

Huffman树是不**唯一**的（节点概率相同时如何选择）

编码树同时作为译码树：每种**合格**的编码都能使用译码树来进行译码，并且结果是唯一的

Huffman编码是变长码且不需要额外的同步信息。

需要注意的问题：

1. 没有错误保护的功能，出现错误传播现象。
2. 无法从指定位置开始译码。

**Huffman编码的特性**：

* 前缀编码：任何一个编码都不是其他任何编码的前缀
* 最优性：最小冗余编码；$H(S)\le \bar{L}\le H(S)+1$
* 信源符号概率是2的负幂次方时，编码效率最高。
* 当所有符号的概率都是2 -k时，平均编码长度等于信源集合的熵。$H(S) = \bar{L}$

huffman编码的效率可以定义成**平均编码长度和信息熵的比**（所有的编码都可以这么计算）

#### 4.2.4 算术编码（Arithmetic Coding，AC）

编码过程：

1. ```c++
   low = 0.0, high = 1.0, range = 1.0
   while(sybol != terminator){
   	get(symbol);
   	low = low + range * range_low(symbol);
   	high = low + range * range_high(symbol);
   	range = high - low;
   }
   output a code, low <= code < high;
   ```

计算过程：

（1）：输入符号$X_1 = a_i$；初始子区间定义为

$I_1 = [l_1,r_1)=[\sum\limits_{i=1}^ip_{i-1},\sum\limits_{i=1}^ip_{i})$

设$L=l_1,R=r_1,d_1=r_1-l_1,j=1$

（2）：将L和R转换为二进制小数形式，依次比较小数点后第$j$位：

$u_k == v_k？print(u_k)，j+=1:goto（3）$

（3）：n += 1，读入下一个符号X~n~=a~i~，将区间细分：

$I_n = [l_n,r_n)=[l_{n-1}+d_{n-1}\sum\limits_{i=1}^ip_{i-1},l_{n-1}+d_{n-1}\sum\limits_{i=1}^ip_{i})$

令$L=l_n,R=r_n,d_1=r_n-l_n，goto（2）$

需要注意的几个**问题**：

1. 由于实际的计算机的精度不可能无限长，要考虑**溢出**问题。
2. 算术编码器对整个消息只产生一个码字，这个码字是在间隔[0, 1)中的一个实数，因此译码器在接受到表示这个实数的所有位之前不能进行译码。
3. 算术编码也是一种**对错误很敏感**的编码方法，如果有一位发生错误就会导致整个消息译错。

**算术编码的效率**：某些情况下，算数编码的性能优于Huffman编码。因为算术编码将整个消息看作一个单元，而Huffman编码受到了必须为每个符号分配整数位的限制。

**游程编码（run-length coding）**：针对包含有顺序排列的多次重复数据的压缩方案

游程长度：连续且重复的单元的数目（黑白图像）

#### 4.2.5 词典编码

通用编码技术：对未知信源的数据进行编码

**词典编码**：自适应信源的统计规律

第一类词典编码的基本思想：查找正在压缩的字符序列是否在前面输入的数据中出现过，如果是，则用对应的指针替代重复的字符串。

第二类算法的思想：从输入的数据中创建一个短语词典，在编码过程中，遇到已经在词典中出现的短语时，用索引号代替出现的字符串。

几个编解码算法成功的条件：

* 编码器自适应程序造成的延迟和复杂性必须能够被系统所接受
* 信源的统计特征必须足够平稳，从而让编码器在统计变化之前就能适应
* 在编码器和解码器中事先统一好自适应程序，使解码器在无损的解码数据流中保持与编码器同步，而不需要编码器另送一组信息来描述其适应过程

**LZ77编码**

几个术语：

输入字符流(input stream):要被压缩的字符序列。
字符(character):输入字符流中的基本单元。
编码位置(coding position):输入字符流中当前要编码的字符位置指前向缓冲存储器中的开始字符。
前向缓冲存储器(Lookahead buffer):存放从编码位置到输入字符流结束的字符序列的存储器。
窗口(window):指包含W个字符的窗口，字符是从编码位置开始向后数也就是最后处理的字符数。
指针(pointer):指向窗口中的匹配串且含长度的指针

具体步骤：

1. 把编码位置设置到输入字符流的开始位置；
2. 查找窗口中最长的匹配串；
3. 以“(Offset,.Length)Character'”的格式输出，其中of是指向窗口中匹配串的指针，Length表示匹配字符的长度，Character是前向缓冲存储器中的不匹配的第1个字符；
4. 如果前向缓冲存储器不是空的，则把编码位置和窗口向前移(Length+1)个字符，然后返回到步骤2。

LZ77编码的冗余：空指针，编码器输出额外的字符可能包含在下一个匹配串中

**LZSS编码**

算法：如果匹配串的长度比指针本身的长度长就输出指针，否则就输出真实字符	

缺点：额外的标志位

具体步骤：

1. 把编码位置设置到输入字符流的开始位置；
2. 查找窗口中最长的匹配串，判断匹配串长度`length`是否大于等于最小匹配串长度；如果是：输出指针，然后编码位置移动`length`个字符；如果否：输出第一个字符，然后编码位置移动一个字符
3. 如果前向缓冲存储器不是空的，返回到步骤2。

相同条件下，LZSS比LZ77压缩比更高（平均编码长度比上字符长度）

**LZ78编码**

建立词典的算法：

约定：

1. 字符流：要被编码的数据序列
2. 字符：字符流中的基本数据单元
3. 前缀：在一个字符之前的字符序列
4. 缀-符串：前缀 + 字符
5. 码字：编码以后在码字流中的基本数据单元
6. 码字流：编码器的输出
7. 词典：缀-符串表。
8. 当前前缀：在编码算法中使用，指当前正在处理的前缀，用P表示
9. 当前字符：当前前缀之后的字符，用C表示
10. 当前码字：当前处理的码字，用W表示，String.W表示当前码字的缀-符串

编码具体步骤：

1. 开始时词典和当前前缀P都是空（P为空时对应的码字是0）
2. 当前字符C=字符流中的下一个字符
3. 判断P+C是否在词典中：
   1. 如果是：P=P+C
   2. 如果否：输出与当前前缀P对应的码字和当前字符C，把P+C添加到词典中，令P=空
4. 判断是否需要继续编码
   1. 如果否：若当前前缀P不是空的话，输出码字然后结束编码
   2. 如果是：返回步骤2

译码算法：

1. 词典为空
2. 得到当前码字W和字符C
3. 将当前码字对应的缀符串（String.W）和字符C输出，把String.W+C添加到词典中
4. 判断是否继续译码，如果是返回步骤2

LZ78实际将字符流划分成K段，计算机需要$[\log_2K]+1$位来描述这个段

**LZW编码**

编码过程：

1. 开始时的词典包含所有可能的根（Root），当前前缀P为空
2. 当前字符C
3. 判断P+C是否词典中：
   1. 如果是：P = P + C
   2. 如果否：
      1. 把代表当前前缀P的码字输出到码字流
      2. 把缀符串 P+C添加到词典
      3. 令P = C
4. 判断是否需要继续编码
   1. 是：返回步骤2
   2. 否：把当前前缀P的码字输出到码字流，结束编码

解码过程

1. 初始状态，字典里只有所有的默认项，此时pW和cW都是空的。
2. 读入第一个的当前码字cW，解码输出。
3. 赋值pW=cW。
4. 读入下一个当前码字cW。
5. 在字典里查找cW，如果:
   1. cW在字典里：
        (1) 解码cW，即输出 Str(cW)。
        (2) 令P=Str(pW)，C=Str(cW)的**第一个字符**。
        (3) 在字典中为P+C添加新的记号映射。
   2. cW不在字典里:
        (1) 令P=Str(pW)，C=Str(pW)的**第一个字符**。
        (2) 在字典中为P+C添加新的记号映射，这个新的记号一定就是cW。
        (3) 输出P+C。
6. 返回步骤3重复，直至读完所有记号。

效率分析：$\phi_k 要用[\log_2(k+2)]$

### 4.3 有损编码

**量化**：通过量化把不同值的数量减少

**均匀量化**：将输入值域划分成等间隔的区间

**非均匀量化**：在源密集分布的区域增加判定级数量

**变换编码**：如果Y是对输入向量X进行线性变换T的结果，线性变换T使得Y的元素间的相关性比X中元素的相关性更弱，那么对Y的编码效率就比对X编码的效率高。

常用方法：离散余弦变换（DCT）

### 4.4 音频压缩技术

常见已有的3种类型编译码器

波形编译码器（时域法{PCM、DPCM、ADPCM}和频域法）、音源编译码器、混合编译码器

#### 4.4.1 PCM编码（pulse code modulation）

PCM编码对每个采样信号的整个幅度进行量化编码

采样频率：根据Nyquist法则以及对音频质量的要求来确定

量化方法：均匀（线性）和非均匀
均匀量化面临的问题：样本位数没有充分利用

非均匀量化：$\mu$律或$A$律PCM编码

#### 4.4.2 DPCM编码

差值编码

预测技术

量化 预测值与实际值的差值

#### 4.4.3 增量调制和自适应增量调制

增量调制DM（$\Delta$调制）是一种预测编码技术，DM是对实际的采样信号与预测的采样信号之差的极性进行编码，用一位2进制数进行编码。

如果实际的采样信号与预测的采样信号之差的极性为“正”，则 用“1”表示。否则用0表示

**斜率过载**：增量调制器的输出不能保持跟踪输入信号的快速变化。

**粒状噪声**：在输入信号缓慢变化部分，即输入信号与预测信号的差值接近零 的区域，增量调制器的输出出现随机交变的“0”和“1”。

为了避免出现斜率过载，要加大量化阶。而为了避免出现粒状噪声，要减小量化阶。

**自适应增量调制**：在检测到斜率过载时开始增大量化阶$\Delta$，在输入信号斜率减小时降 低量化阶$\Delta$。

#### 4.4.4 自适应差分脉冲编码调制

根据输入信号幅度大小来改变量化阶大小

改变量化阶大小的方法：前向自适应，后向自适应。

#### 4.4.5 ADPCM

结合了APCM的自适应特性和DPCM系统的差分特性

核心思想：

- 利用自适应的思想改变量化阶的大小，即使用小的量化阶(step-size)去编码小的差值，使用大的量化阶去编码大的差值。
- 使用过去的样本值估算下一个输入样本的预测值，使实际样本值和预测值之间的差值总是最小

#### 4.4.6 频域编码方法-子带编码

带宽：频率的变化范围

主要过程：

使用一组带通滤波器（BPF）把输入音频信号的频带分成若干个连续的频段，分别采用单独的编码方案，最后复合

![image-20230422135021382](https://cdn.staticaly.com/gh/LuoChen-LC/picx-images-hosting@master/20230603/image-20230422135021382.7cpnp6g2ko80.png)

#### 4.4.7 MPEG中的音频编码

压缩过程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200604213318946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyNjk1OA==,size_16,color_FFFFFF,t_70#pic_center)

基本思想：

分析信号，去掉不能被感知的部分

**心理声学模型**：听觉系统中存在一个听觉阈值电平，听觉阈值电平是自适应的

**人耳听觉系统**：等效于一个信号通过一组并联的不同中心频率的带通滤波器

### 4.5 静态图像压缩技术

#### 4.5.1 CCITT Group 3 1D

CCITT Group 3 1D压缩算法：基于游程编码

以黑白像素出现的概率为基础，确定不同游程的编码

CCITT Group 3有确定的游程码表

编排码（64的倍数）加终止码（0-64）

缺点：没有提供任何错误保护机制。没有利用相邻扫描线的相似特性

#### 4.5.2 CCITT Group 3 2D

算法依据：横跨相邻两条扫描线的图像数据可能是冗余的。如果在一指定线上出现了黑白过渡，那么有可能在下一扫描线上加或减三个像素之间的位置上也出现相同的过渡。

基本方法：使用K因子，将扫描线每K条放在一起处理，每组的第一条使用1D方法编码，以这条线为参考线，为其余扫描线编码。

2D方法使用附加码：垂直码，越过码，水平码。

* 越过码固定取值：0001
* 水平码固定取值：001
* 垂直码有7个，由参考线与当前编码线的差异决定

K因子可以提供错误保护

#### 4.5.3 CCITT Group 4 2D

一种没有使用K因子的二维编码方式，压缩率更高，但是没有错误保护。同时无法从指定位置开始译码

#### 4.5.4 JPEG静态图像压缩编码

2. JPEG无失真压缩：预测编码技术

   JPEG有损压缩：（1）使用正向离散余弦变换；（2）使用加权函数对DCT系数进行量化；（3）使用哈夫曼编码器对量化系数进行编码；（4）组成位流

   1. 离散余弦变换（DCT）：划分成8✖8的图像块并用一个二维数组 **f** 维护，通过变换生成另一个二维数组 **F**。$f(i,j)$经DCT得到$F(i,j)$，其中    F（0，0）是直流系数，称为DC系数，其他为交流系数，称为AC系数
   
      在实际算法实现中，对灰度级$2^n$级的像素通过减去$2^{n-1}$，使得像素的绝对值出现3位10进制的概率大大减少。
   
   2. 量化：对经过DCT变换后的系数进行量化。目的是减小非0系数的幅度以及增加0值系数的数目。量化是图像质量下降的最主要原因。
   
      使用量化表：色度量化表和亮度量化表
   
      量化后的数组叫做 **Q** 数组
   
      解码的时候要进行逆量化和逆向离散余弦变换，并且变换后加上$2^{n-1}$
   
   3. 编码：
   
      Z字形编排：Zig-zig
   
      DC系数编码：相邻图像块之间量化DC系数的差值（DPCM）进行编码：
   
      $Delta=Dc(0,0)_k-Dc(0,0)_{k-1}$
   
      用（size（位数），amplitude（值））（编码取反表示负数）表示
   
      最后对SIZE进行Huffman编码
   
      AC系数编码：使用RLE编码，{runlength（0的个数），value（下一个非0系数）}，用（0，0）紧跟最后一个非0的AC系数表示结尾
   
      熵编码：对AC系数，value可以用 size 和 amplitude 的方式表示，runlength 和 size 共用一个字节，采用 huffman 编码，amplitude 用一个字节。当0串的长度超过15时，用特殊编码（15，0）扩展。
   
   4. 组成位数据流
   
      把各种标记代码和编码组成一帧一帧的数据
   
      帧：一幅图片
   
      帧头：像素的位数，图像的宽高等信息
   
   5. JPEG模式
   
      * 顺序模式：默认从上到下，从左到右扫描并编码
      * 渐进模式：首先传送低质量图片，接着传送高质量的图片
        * 第一次扫描：对DC和前几个AC分量编码，后面依次对更多的AC分量编码
        * 对最高有效位优先编码，后面依次对稍低的位编码
      * 分级模式：对不同分辨率层次中的图像进行编码
      * 无损模式
   
   #### 4.5.5 JPEG 2000
   
   以DWT（离散小波变换算法）为主的多解析编码方式
   
   EBCOT（最优截断嵌入式块编码）
   
   JPEG 2000 主要由6部分组成：图像编码系统，扩展系统，运动JPEG 2000，兼容性，参考软件，复合图像格式
   
   ### 4.6 视频压缩编码
   
   #### 4.6.1 MPEG标准概述
   
   MPEG一般分为视频，音频，视音频三个部分
   
   04年为止，MPEG标准有：MPEG-1，MPEG-2，MPEG-4，MPEG-7，MPEG-21
   
   MPEG-1 五部分：系统，视频，音频，一致性测试，软件模拟
   
   信息冗余：空间，时间，编码，结构
   
   时间冗余：相邻帧具有很强的相似性
   
   #### 4.6.2 MPEG-1压缩编码
   
   用于数据速率高达1.5Mbps的数字存储
   
   视频压缩标准的基本方法：
   
   * 基于离散变换的压缩
   * 基于块的运动补偿
   
   具体实现：采用帧内图像数据压缩和帧间图像数据压缩技术
   
   三种图像：帧内图像 **I** （关键帧），预测图像 **P**（以关键帧作为参考） ，双向预测图像 **B** （以I帧和P帧作为参考）。
   
   **帧内压缩算法**：
   
   ![image-20230430225113691](https://cdn.staticaly.com/gh/LuoChen-LC/picx-images-hosting@master/20230603/image-20230430225113691.40xixbv2az40.png)
   
   **P帧编码**
   
   差值和移动矢量
   
   ![image-20230430225456394](https://cdn.staticaly.com/gh/LuoChen-LC/picx-images-hosting@master/20230603/image-20230430225456394.4aich9rkp9k0.png)
   
   块的匹配算法：
   
   1. 匹配准则：均方误差，平均绝对误差
   2. 搜索算法：顺序搜索，2D对数搜索，分层搜索
   
   **B帧编码**
   
   ![image-20230430225701312](https://cdn.staticaly.com/gh/LuoChen-LC/picx-images-hosting@master/20230603/image-20230430225701312.5h5ef11pzjo0.png)
   
   帧的编排顺序：
   
   ![image-20230430230615509](https://cdn.staticaly.com/gh/LuoChen-LC/picx-images-hosting@master/20230603/image-20230430230615509.ld4a51w8qeo.png)
   
   #### 4.6.3 MPEG-2 压缩编码
   
   
   
   
